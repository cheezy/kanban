defmodule KanbanWeb.MetricsExcelExport do
  @moduledoc """
  Generates Excel (.xlsx) exports for metrics data.
  Supports both AI-optimized and regular board types with appropriate columns/labels.
  """

  alias Elixlsx.Sheet
  alias Elixlsx.Workbook
  alias KanbanWeb.MetricsLive.Helpers

  @col_widths_base %{1 => 12, 2 => 40, 3 => 22, 4 => 22, 5 => 22, 6 => 20}
  @bold [bold: true]

  def generate(board, metric, opts, data) do
    sheet = build_sheet(board, metric, opts, data)
    workbook = %Workbook{sheets: [sheet]}

    case Elixlsx.write_to_memory(workbook, "export.xlsx") do
      {:ok, {_filename, binary}} -> {:ok, binary}
      {:error, reason} -> {:error, reason}
    end
  end

  defp build_sheet(board, "throughput", opts, data) do
    header = header_rows(board, "Throughput", opts)
    {task_headers, task_rows} = throughput_task_rows(board, data)
    {goal_headers, goal_rows} = throughput_goal_rows(board, data)

    rows =
      header ++
        [task_headers | task_rows] ++
        [[]] ++
        [goal_headers | goal_rows]

    %Sheet{name: "Throughput", rows: rows, col_widths: @col_widths_base}
  end

  defp build_sheet(board, "cycle-time", opts, data) do
    header = header_rows(board, "Cycle Time", opts)
    {col_headers, data_rows} = cycle_time_rows(board, data)
    rows = header ++ [col_headers | data_rows]
    %Sheet{name: "Cycle Time", rows: rows, col_widths: @col_widths_base}
  end

  defp build_sheet(board, "lead-time", opts, data) do
    header = header_rows(board, "Lead Time", opts)
    {col_headers, data_rows} = lead_time_rows(board, data)
    rows = header ++ [col_headers | data_rows]
    %Sheet{name: "Lead Time", rows: rows, col_widths: @col_widths_base}
  end

  defp build_sheet(board, "wait-time", opts, data) do
    header = header_rows(board, "Wait Time", opts)

    review_section =
      if ai_optimized?(board) do
        {review_headers, review_rows} = review_wait_rows(board, data)
        [[["Reviewed Tasks" | @bold]]] ++ [review_headers | review_rows] ++ [[]]
      else
        []
      end

    {backlog_headers, backlog_rows} = backlog_wait_rows(board, data)
    backlog_label = if ai_optimized?(board), do: "Claimed Tasks", else: "Started Tasks"

    rows =
      header ++
        review_section ++
        [[[backlog_label | @bold]]] ++
        [backlog_headers | backlog_rows]

    %Sheet{name: "Wait Time", rows: rows, col_widths: @col_widths_base}
  end

  defp build_sheet(board, _metric, opts, _data) do
    rows = header_rows(board, "Unknown", opts)
    %Sheet{name: "Export", rows: rows, col_widths: @col_widths_base}
  end

  # Header rows (rows 1-4)

  defp header_rows(board, metric_label, opts) do
    time_range_label = format_time_range(opts[:time_range])
    weekends_label = if opts[:exclude_weekends], do: "Excluded", else: "Included"
    generated_at = Calendar.strftime(DateTime.utc_now(), "%b %d, %Y %I:%M %p")

    row1 = [["#{metric_label} Metrics — #{board.name}" | @bold]]

    filter_parts = ["Time Range: #{time_range_label}", "Weekends: #{weekends_label}"]

    filter_parts =
      if ai_optimized?(board) do
        agent_label = opts[:agent_name] || "All Agents"
        filter_parts ++ ["Agent: #{agent_label}"]
      else
        filter_parts
      end

    row2 = [Enum.join(filter_parts, " | ")]
    row3 = ["Generated by Stride | #{generated_at}"]

    [row1, row2, row3, []]
  end

  # Throughput rows

  defp throughput_task_rows(board, data) do
    tasks = Map.get(data, :tasks, [])

    headers =
      if ai_optimized?(board) do
        bold_row(["Identifier", "Title", "Created", "Claimed", "Completed", "Agent"])
      else
        bold_row(["Identifier", "Title", "Created", "Completed"])
      end

    rows =
      Enum.map(tasks, fn task ->
        base = [
          task[:identifier],
          task[:title],
          format_datetime_cell(task[:inserted_at])
        ]

        if ai_optimized?(board) do
          base ++
            [
              format_datetime_cell(task[:claimed_at]),
              format_datetime_cell(task[:completed_at]),
              task[:completed_by_agent] || "—"
            ]
        else
          base ++ [format_datetime_cell(task[:completed_at])]
        end
      end)

    {headers, rows}
  end

  defp throughput_goal_rows(board, data) do
    goals = Map.get(data, :completed_goals, [])

    headers =
      if ai_optimized?(board) do
        bold_row(["Identifier", "Title", "Created", "Completed", "Agent"])
      else
        bold_row(["Identifier", "Title", "Created", "Completed"])
      end

    rows =
      Enum.map(goals, fn goal ->
        base = [
          goal[:identifier],
          goal[:title],
          format_datetime_cell(goal[:inserted_at]),
          format_datetime_cell(goal[:completed_at])
        ]

        if ai_optimized?(board) do
          base ++ [goal[:completed_by_agent] || "—"]
        else
          base
        end
      end)

    {headers, rows}
  end

  # Cycle Time rows

  defp cycle_time_rows(board, data) do
    tasks = Map.get(data, :tasks, [])
    claimed_label = if ai_optimized?(board), do: "Claimed", else: "Started"

    headers =
      if ai_optimized?(board) do
        bold_row(["Identifier", "Title", "Cycle Time", claimed_label, "Completed", "Agent"])
      else
        bold_row(["Identifier", "Title", "Cycle Time", claimed_label, "Completed"])
      end

    rows =
      Enum.map(tasks, fn task ->
        base = [
          task[:identifier],
          task[:title],
          format_time_cell(task[:cycle_time_seconds]),
          format_datetime_cell(task[:claimed_at]),
          format_datetime_cell(task[:completed_at])
        ]

        if ai_optimized?(board) do
          base ++ [task[:completed_by_agent] || "—"]
        else
          base
        end
      end)

    {headers, rows}
  end

  # Lead Time rows

  defp lead_time_rows(board, data) do
    tasks = Map.get(data, :tasks, [])

    headers =
      if ai_optimized?(board) do
        bold_row(["Identifier", "Title", "Lead Time", "Created", "Completed", "Agent"])
      else
        bold_row(["Identifier", "Title", "Lead Time", "Created", "Completed"])
      end

    rows =
      Enum.map(tasks, fn task ->
        base = [
          task[:identifier],
          task[:title],
          format_time_cell(task[:lead_time_seconds]),
          format_datetime_cell(task[:inserted_at]),
          format_datetime_cell(task[:completed_at])
        ]

        if ai_optimized?(board) do
          base ++ [task[:completed_by_agent] || "—"]
        else
          base
        end
      end)

    {headers, rows}
  end

  # Wait Time rows

  defp review_wait_rows(_board, data) do
    tasks =
      data
      |> Map.get(:grouped_review_tasks, [])
      |> Enum.flat_map(fn {_date, tasks} -> tasks end)

    headers =
      bold_row(["Identifier", "Title", "Review Wait", "Completed", "Reviewed", "Agent"])

    rows =
      Enum.map(tasks, fn task ->
        [
          task[:identifier],
          task[:title],
          format_time_cell(task[:review_wait_seconds]),
          format_datetime_cell(task[:completed_at]),
          format_datetime_cell(task[:reviewed_at]),
          task[:completed_by_agent] || "—"
        ]
      end)

    {headers, rows}
  end

  defp backlog_wait_rows(board, data) do
    tasks =
      data
      |> Map.get(:grouped_backlog_tasks, [])
      |> Enum.flat_map(fn {_date, tasks} -> tasks end)

    wait_label = if ai_optimized?(board), do: "Backlog Wait", else: "Queue Wait"
    claimed_label = if ai_optimized?(board), do: "Claimed", else: "Started"

    headers =
      if ai_optimized?(board) do
        bold_row(["Identifier", "Title", wait_label, "Created", claimed_label, "Agent"])
      else
        bold_row(["Identifier", "Title", wait_label, "Created", claimed_label])
      end

    rows =
      Enum.map(tasks, fn task ->
        base = [
          task[:identifier],
          task[:title],
          format_time_cell(task[:backlog_wait_seconds]),
          format_datetime_cell(task[:inserted_at]),
          format_datetime_cell(task[:claimed_at])
        ]

        if ai_optimized?(board) do
          base ++ [task[:completed_by_agent] || "—"]
        else
          base
        end
      end)

    {headers, rows}
  end

  # Helpers

  defp ai_optimized?(board), do: board.ai_optimized_board

  defp bold_row(cells), do: Enum.map(cells, fn cell -> [cell | @bold] end)

  defp format_datetime_cell(nil), do: "N/A"
  defp format_datetime_cell(datetime), do: Helpers.format_datetime(datetime)

  defp format_time_cell(nil), do: "N/A"
  defp format_time_cell(seconds), do: Helpers.format_time(seconds)

  defp format_time_range(:today), do: "Today"
  defp format_time_range(:last_7_days), do: "Last 7 Days"
  defp format_time_range(:last_30_days), do: "Last 30 Days"
  defp format_time_range(:last_90_days), do: "Last 90 Days"
  defp format_time_range(:all_time), do: "All Time"
  defp format_time_range(_), do: "Last 30 Days"
end
