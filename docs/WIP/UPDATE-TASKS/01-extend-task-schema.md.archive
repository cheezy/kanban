# Extend Task Schema with JSONB Collections

**Complexity:** Large | **Est. Files:** 6-8 | **Est. Time:** 4-6 hours

## Description

**WHY:** Current task schema only has title, description, and position. Need to store the rich task information from TASKS.md format using proper database columns with JSONB for collections to enable better querying, type safety, and data integrity.

**WHAT:** Add database columns to tasks table for complexity, key files, verification steps, observability requirements, and other TASKS.md fields. Use JSONB columns for structured collections (key files, verification steps, pitfalls, out of scope) with Ecto embedded schemas for type safety.

**WHERE:** Task schema, migrations, context module, and embedded schema definitions

## Acceptance Criteria

- [ ] Migration adds new columns to tasks table
- [ ] JSONB columns store collections with schema validation
- [ ] Embedded schemas defined for KeyFile, VerificationStep, etc.
- [ ] Task schema updated with new fields and embeds
- [ ] Changeset validates new fields and casts embeds
- [ ] Complexity field validates enum values (small, medium, large)
- [ ] Default values set appropriately
- [ ] Existing tasks compatible (nullable fields)
- [ ] New tests written for all new fields and embeds
- [ ] Tests validate JSONB storage and embedded schema casting
- [ ] All existing tests pass after migration
- [ ] JSONB queries work efficiently with GIN indexes

## Key Files to Read First

- `lib/kanban/schemas/task.ex` - Current task schema (all fields)
- `lib/kanban/tasks.ex` - Task context module
- `priv/repo/migrations/` - Check latest migration number
- `test/kanban/tasks_test.exs` - Task tests to update
- `docs/WIP/TASKS.md` - Reference format (understand 18 categories)

## Technical Notes

**Patterns to Follow:**
- Use proper database columns for scalar values (complexity, estimated_files, etc.)
- Use JSONB columns for collections with embedded schemas
- Follow Ecto embedded schema patterns for type safety
- Use GIN indexes on JSONB columns for efficient querying
- Follow existing naming conventions in the project
- Nullable columns for backward compatibility

**Database/Schema:**
- Tables: tasks (extend only - keep flat structure)
- Migrations needed: Yes - single migration adding columns to tasks table
- Indexes: GIN indexes on JSONB columns for fast querying

**New columns on tasks table:**

**Scalar fields:**
- `complexity` (string) - Enum: small, medium, large
- `estimated_files` (string) - "1-2", "2-3", "3-5", "5+"
- `why` (text) - Problem being solved
- `what` (text) - Specific feature/change
- `where_context` (text) - UI location or code area
- `patterns_to_follow` (text) - Existing patterns to use
- `database_changes` (text) - Migration/schema notes
- `telemetry_event` (string) - Event name like "[:kanban, :task, :action]"
- `metrics_to_track` (text) - What to measure
- `logging_requirements` (text) - What to log
- `error_user_message` (text) - What user sees on error
- `error_on_failure` (text) - What happens on failure
- `validation_rules` (text) - Input validation needed

**JSONB collection fields:**
- `key_files` (jsonb) - Array of {file_path, note, position}
- `verification_steps` (jsonb) - Array of {step_type, step_text, expected_result, position}
- `technology_requirements` (jsonb) - Array of strings
- `pitfalls` (jsonb) - Array of strings
- `out_of_scope` (jsonb) - Array of strings

**Integration Points:**
- [ ] PubSub broadcasts: Broadcast task updates with new fields to board channels
- [ ] Phoenix Channels: None (uses existing board PubSub)
- [ ] External APIs: None

## Verification

**Commands to Run:**
```bash
# Create migration
mix ecto.gen.migration extend_tasks_with_ai_fields

# Edit migration, then run
mix ecto.migrate

# Run tests
mix test test/kanban/tasks_test.exs
mix test test/kanban/schemas/task_test.exs
mix test test/kanban/schemas/task/embedded_test.exs

# Verify in console
iex -S mix
alias Kanban.{Repo, Schemas.Task, Tasks}

# Create task with new fields (using embedded schemas)
{:ok, task} = Tasks.create_task(%{
  title: "Add priority filter",
  complexity: :medium,
  estimated_files: "2-3",
  why: "Users need to focus on high-priority tasks",
  what: "Add dropdown filter for task priority (0-4)",
  where_context: "Board list view header",
  telemetry_event: "[:kanban, :filter, :used]",
  key_files: [
    %{file_path: "lib/kanban_web/live/board_live.ex", note: "Main LiveView", position: 1},
    %{file_path: "lib/kanban_web/live/board_live.html.heex", note: "Board template", position: 2}
  ],
  verification_steps: [
    %{step_type: "command", step_text: "mix test test/kanban/boards_test.exs", expected_result: "All tests pass", position: 1}
  ],
  technology_requirements: ["Phoenix PubSub", "Phoenix LiveView"],
  pitfalls: [
    "Don't forget to handle nil priority values",
    "Remember to broadcast filter changes"
  ],
  out_of_scope: [
    "Priority editing in this task",
    "Sorting by priority"
  ]
})

# Verify JSONB data stored correctly
IO.inspect(task.key_files, label: "Key files (JSONB)")

# Test JSONB querying
import Ecto.Query
from(t in Task,
  where: fragment("? @> ?", t.technology_requirements, ^["Phoenix LiveView"]))
|> Repo.all()

# Run all checks
mix precommit
```

**Manual Testing:**
1. Run migration successfully
2. Create new task with rich fields via iex
3. Verify JSONB fields store structured data correctly
4. Query tasks using JSONB operators
5. Update existing task - verify backward compatibility
6. Check board UI still displays tasks
7. Verify embedded schemas validate data types

**Success Looks Like:**
- Migration runs without errors
- New columns in tasks table with JSONB types
- Can create/update tasks with structured collections
- JSONB queries work efficiently with GIN indexes
- Embedded schemas provide type safety
- Existing tasks still work (nulls handled)
- No breaking changes to existing UI
- All 552 tests still pass

## Data Examples

**Migration:**
```elixir
defmodule Kanban.Repo.Migrations.ExtendTasksWithAiFields do
  use Ecto.Migration

  def change do
    # Extend tasks table with all AI-optimized fields
    alter table(:tasks) do
      # Complexity and scope
      add :complexity, :string
      add :estimated_files, :string

      # Context fields
      add :why, :text
      add :what, :text
      add :where_context, :text

      # Technical notes
      add :patterns_to_follow, :text
      add :database_changes, :text

      # Observability
      add :telemetry_event, :string
      add :metrics_to_track, :text
      add :logging_requirements, :text

      # Error handling
      add :error_user_message, :text
      add :error_on_failure, :text
      add :validation_rules, :text

      # Collections stored as JSONB for efficient querying and type safety
      add :key_files, :jsonb
      add :verification_steps, :jsonb
      add :technology_requirements, :jsonb
      add :pitfalls, :jsonb
      add :out_of_scope, :jsonb
    end

    # Create GIN indexes on JSONB columns for fast querying
    create index(:tasks, [:key_files], using: :gin)
    create index(:tasks, [:verification_steps], using: :gin)
    create index(:tasks, [:technology_requirements], using: :gin)
  end
end
```

**Embedded Schemas:**
```elixir
defmodule Kanban.Schemas.Task.KeyFile do
  @moduledoc """
  Embedded schema for key files in a task.
  Stored in JSONB column for efficient querying and type safety.
  """
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key false
  embedded_schema do
    field :file_path, :string
    field :note, :string
    field :position, :integer
  end

  def changeset(key_file, attrs) do
    key_file
    |> cast(attrs, [:file_path, :note, :position])
    |> validate_required([:file_path, :position])
  end
end

defmodule Kanban.Schemas.Task.VerificationStep do
  @moduledoc """
  Embedded schema for verification steps in a task.
  """
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key false
  embedded_schema do
    field :step_type, :string  # "command" or "manual"
    field :step_text, :string
    field :expected_result, :string
    field :position, :integer
  end

  def changeset(step, attrs) do
    step
    |> cast(attrs, [:step_type, :step_text, :expected_result, :position])
    |> validate_required([:step_type, :step_text, :position])
    |> validate_inclusion(:step_type, ["command", "manual"])
  end
end
```

**Schema Update:**
```elixir
defmodule Kanban.Schemas.Task do
  use Ecto.Schema
  import Ecto.Changeset

  alias Kanban.Schemas.Task.{KeyFile, VerificationStep}

  schema "tasks" do
    # Existing fields
    field :title, :string
    field :description, :string
    field :position, :integer
    field :type, Ecto.Enum, values: [:work, :defect], default: :work
    field :priority, Ecto.Enum, values: [:low, :medium, :high, :critical], default: :medium
    field :identifier, :string
    belongs_to :column, Kanban.Schemas.Column
    belongs_to :assigned_to, Kanban.Schemas.User

    # New AI-optimized scalar fields
    field :complexity, Ecto.Enum, values: [:small, :medium, :large]
    field :estimated_files, :string
    field :why, :string
    field :what, :string
    field :where_context, :string
    field :patterns_to_follow, :string
    field :database_changes, :string
    field :telemetry_event, :string
    field :metrics_to_track, :string
    field :logging_requirements, :string
    field :error_user_message, :string
    field :error_on_failure, :string
    field :validation_rules, :string

    # JSONB collection fields with embedded schemas
    embeds_many :key_files, KeyFile, on_replace: :delete
    embeds_many :verification_steps, VerificationStep, on_replace: :delete
    field :technology_requirements, {:array, :string}
    field :pitfalls, {:array, :string}
    field :out_of_scope, {:array, :string}

    timestamps()
  end

  def changeset(task, attrs) do
    task
    |> cast(attrs, [
      :title, :description, :position, :type, :priority,
      :complexity, :estimated_files, :why, :what, :where_context,
      :patterns_to_follow, :database_changes,
      :telemetry_event, :metrics_to_track,
      :logging_requirements, :error_user_message,
      :error_on_failure, :validation_rules,
      :technology_requirements, :pitfalls, :out_of_scope
    ])
    |> cast_embed(:key_files)
    |> cast_embed(:verification_steps)
    |> validate_required([:title])
    |> validate_inclusion(:estimated_files, ["1-2", "2-3", "3-5", "5+"], allow_nil: true)
  end
end
```

**JSONB Querying Examples:**
```elixir
import Ecto.Query

# Find tasks that include a specific file
from t in Task,
  where: fragment(
    "EXISTS (SELECT 1 FROM jsonb_array_elements(?) AS elem WHERE elem->>'file_path' = ?)",
    t.key_files,
    "lib/kanban/tasks.ex"
  )

# Find tasks that use Phoenix LiveView
from t in Task,
  where: fragment("? @> ?::jsonb", t.technology_requirements, "[\"Phoenix LiveView\"]")

# Find tasks with command verification steps
from t in Task,
  where: fragment(
    "EXISTS (SELECT 1 FROM jsonb_array_elements(?) AS elem WHERE elem->>'step_type' = 'command')",
    t.verification_steps
  )

# Count tasks by complexity with AI fields populated
from t in Task,
  where: not is_nil(t.complexity),
  group_by: t.complexity,
  select: {t.complexity, count(t.id)}
```

## Testing

### New Tests to Write

**Embedded Schema Tests (test/kanban/schemas/task/embedded_test.exs - NEW FILE):**

1. **Test KeyFile embedded schema:**
   ```elixir
   defmodule Kanban.Schemas.Task.EmbeddedTest do
     use Kanban.DataCase
     alias Kanban.Schemas.Task.{KeyFile, VerificationStep}

     describe "KeyFile" do
       test "valid changeset with all fields" do
         attrs = %{
           file_path: "lib/app.ex",
           note: "Main module",
           position: 1
         }

         changeset = KeyFile.changeset(%KeyFile{}, attrs)
         assert changeset.valid?
       end

       test "requires file_path and position" do
         changeset = KeyFile.changeset(%KeyFile{}, %{})
         refute changeset.valid?
         assert %{file_path: ["can't be blank"]} = errors_on(changeset)
         assert %{position: ["can't be blank"]} = errors_on(changeset)
       end

       test "note is optional" do
         changeset = KeyFile.changeset(%KeyFile{}, %{
           file_path: "lib/app.ex",
           position: 1
         })
         assert changeset.valid?
       end
     end

     describe "VerificationStep" do
       test "valid changeset with all fields" do
         attrs = %{
           step_type: "command",
           step_text: "mix test",
           expected_result: "All pass",
           position: 1
         }

         changeset = VerificationStep.changeset(%VerificationStep{}, attrs)
         assert changeset.valid?
       end

       test "validates step_type is command or manual" do
         changeset = VerificationStep.changeset(%VerificationStep{}, %{
           step_type: "invalid",
           step_text: "test",
           position: 1
         })

         refute changeset.valid?
         assert %{step_type: ["is invalid"]} = errors_on(changeset)
       end
     end
   end
   ```

**Schema Tests (test/kanban/schemas/task_test.exs):**

2. **Test complexity enum validation:**
   ```elixir
   test "validates complexity is small, medium, or large" do
     valid_changeset = Task.changeset(%Task{}, %{title: "Test", complexity: :medium})
     assert valid_changeset.valid?

     invalid_changeset = Task.changeset(%Task{}, %{title: "Test", complexity: :huge})
     refute invalid_changeset.valid?
   end

   test "allows nil complexity for backward compatibility" do
     changeset = Task.changeset(%Task{}, %{title: "Test", complexity: nil})
     assert changeset.valid?
   end
   ```

3. **Test JSONB embeds:**
   ```elixir
   test "casts key_files as embedded schemas" do
     attrs = %{
       title: "Test",
       key_files: [
         %{file_path: "lib/app.ex", note: "Main", position: 1},
         %{file_path: "lib/helper.ex", note: "Helper", position: 2}
       ]
     }

     changeset = Task.changeset(%Task{}, attrs)
     assert changeset.valid?
     assert length(get_change(changeset, :key_files)) == 2
   end

   test "validates embedded key_files" do
     attrs = %{
       title: "Test",
       key_files: [
         %{note: "Missing file_path"}  # Invalid - no file_path or position
       ]
     }

     changeset = Task.changeset(%Task{}, attrs)
     refute changeset.valid?
   end
   ```

4. **Test array fields:**
   ```elixir
   test "stores technology_requirements as array" do
     attrs = %{
       title: "Test",
       technology_requirements: ["Phoenix", "Ecto", "PostgreSQL"]
     }

     changeset = Task.changeset(%Task{}, attrs)
     assert changeset.valid?
     assert get_change(changeset, :technology_requirements) == ["Phoenix", "Ecto", "PostgreSQL"]
   end

   test "stores pitfalls as array of strings" do
     attrs = %{
       title: "Test",
       pitfalls: ["Don't forget X", "Remember Y"]
     }

     changeset = Task.changeset(%Task{}, attrs)
     assert changeset.valid?
   end
   ```

**Context Tests (test/kanban/tasks_test.exs):**

5. **Test creating task with embedded schemas:**
   ```elixir
   test "create_task/1 with AI-optimized fields and embeds" do
     column = insert(:column)

     attrs = %{
       title: "AI Task",
       column_id: column.id,
       complexity: :medium,
       estimated_files: "2-3",
       why: "Users need feature",
       what: "Implement feature",
       key_files: [
         %{file_path: "lib/app.ex", note: "Main file", position: 1}
       ],
       verification_steps: [
         %{step_type: "command", step_text: "mix test", expected_result: "Pass", position: 1}
       ],
       technology_requirements: ["Phoenix"],
       pitfalls: ["Watch out for X"]
     }

     assert {:ok, task} = Tasks.create_task(attrs)
     assert task.complexity == :medium
     assert task.estimated_files == "2-3"
     assert length(task.key_files) == 1
     assert hd(task.key_files).file_path == "lib/app.ex"
     assert length(task.verification_steps) == 1
     assert hd(task.verification_steps).step_type == "command"
     assert task.technology_requirements == ["Phoenix"]
   end
   ```

6. **Test updating task preserves embeds:**
   ```elixir
   test "update_task/2 updates embedded schemas" do
     task = insert(:task, key_files: [
       %{file_path: "lib/old.ex", note: "Old", position: 1}
     ])

     assert {:ok, updated} = Tasks.update_task(task, %{
       key_files: [
         %{file_path: "lib/new.ex", note: "New", position: 1}
       ]
     })

     assert length(updated.key_files) == 1
     assert hd(updated.key_files).file_path == "lib/new.ex"
   end
   ```

7. **Test JSONB querying:**
   ```elixir
   test "queries tasks by JSONB fields" do
     # Create tasks with different technologies
     task1 = insert(:task, technology_requirements: ["Phoenix", "Ecto"])
     task2 = insert(:task, technology_requirements: ["React", "Redux"])
     task3 = insert(:task, technology_requirements: ["Phoenix", "LiveView"])

     # Query for Phoenix tasks
     import Ecto.Query
     phoenix_tasks =
       from(t in Task,
         where: fragment("? @> ?::jsonb", t.technology_requirements, "[\"Phoenix\"]")
       )
       |> Repo.all()

     assert length(phoenix_tasks) == 2
     assert task1.id in Enum.map(phoenix_tasks, & &1.id)
     assert task3.id in Enum.map(phoenix_tasks, & &1.id)
   end
   ```

### Test Coverage Requirements

- [ ] All new schema fields have validation tests
- [ ] Complexity enum validation has positive and negative test cases
- [ ] Embedded schemas validate required fields
- [ ] JSONB fields store and retrieve structured data correctly
- [ ] Array fields handle empty arrays and nil values
- [ ] JSONB queries return correct results
- [ ] Backward compatibility tested (existing tasks work with nil fields)
- [ ] Context functions create/update tasks with new fields
- [ ] All existing tests still pass after schema changes

## Observability

- [ ] Telemetry event: `[:kanban, :task, :schema_extended]`
- [ ] Metrics: Count of tasks with AI fields populated by complexity
- [ ] Logging: Log migration completion at info level
- [ ] Logging: Log JSONB query performance for monitoring

## Error Handling

- User sees: Migration errors if database constraints violated
- On failure: Rollback migration automatically (Ecto handles)
- Validation: Changeset validates complexity values, embedded schemas, array fields
- JSONB errors: Invalid JSON structure rejected by database with clear error

## Common Pitfalls

- [ ] Don't make new columns NOT NULL (backward compatibility with existing tasks)
- [ ] Remember JSONB columns need GIN indexes for efficient querying
- [ ] Don't forget to use `cast_embed` for embedded schemas
- [ ] Remember `on_replace: :delete` for embeds_many to handle updates correctly
- [ ] Avoid deeply nested JSONB structures (keep it simple)
- [ ] Don't forget to validate embedded schemas have required fields
- [ ] Remember JSONB queries use fragment() with PostgreSQL operators
- [ ] Test JSONB queries with realistic data volumes (GIN index performance)
- [ ] Handle nil JSONB fields gracefully in queries (use coalesce if needed)
- [ ] Remember array fields are different from embeds (simpler but no validation)

## Dependencies

**Requires:** None (foundational change)
**Blocks:** 02-add-task-metadata-fields.md, 07-implement-task-crud-api.md, 03-display-rich-task-details.md, 04-add-task-creation-form.md

## Out of Scope

- Don't implement UI forms yet (separate task #04)
- Don't add API endpoints yet (separate task #07)
- Don't migrate existing task descriptions to new format
- Don't implement rich text editing for fields
- Don't add complex nested JSONB structures (keep flat)
- Don't create separate tables for collections (keep tasks table flat)
- Don't implement JSONB schema versioning yet (future work)
- Don't add full-text search on JSONB fields (can add later with tsvector)

## Benefits of JSONB Approach

### vs. Text Field Storage

**Advantages:**
1. **Type Safety**: Embedded schemas validate structure at application level
2. **Querying**: PostgreSQL JSONB operators enable efficient filtering
3. **Indexing**: GIN indexes on JSONB columns provide fast lookups
4. **No Parsing**: Direct JSON serialization/deserialization by Ecto
5. **Schema Evolution**: Easy to add fields to embedded schemas over time
6. **Data Integrity**: Database enforces valid JSON structure

**Trade-offs:**
- Slightly more storage space than text (negligible)
- Requires PostgreSQL 9.4+ (we're on 14+, no issue)
- More complex migrations if changing embedded schema structure

### Query Performance

With GIN indexes, JSONB queries are fast even on large datasets:
- Contains operator (`@>`) uses index: O(log n)
- Existence checks use index: O(log n)
- Without index: O(n) sequential scan

**Example performance:**
```sql
-- Fast with GIN index
SELECT * FROM tasks
WHERE technology_requirements @> '["Phoenix"]'::jsonb;

-- Also fast with GIN index
SELECT * FROM tasks
WHERE EXISTS (
  SELECT 1 FROM jsonb_array_elements(key_files) AS kf
  WHERE kf->>'file_path' LIKE 'lib/%'
);
```
